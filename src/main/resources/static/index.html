<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TryOnX - Pose Camera</title>
<style>
    :root{
        --bg:#f5f8fa; --card:#ffffff; --muted:#6b7280; --accent:#0956ff; --accent-2:#00bfa6;
    }
    *{box-sizing:border-box}
    body{margin:0;min-height:100vh;background:var(--bg);color:#0b1320;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    .app{padding:20px;max-width:1080px;margin:0 auto}
    .topbar{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
    .title{font-weight:700;font-size:20px;letter-spacing:0.2px;color:#07203a}
    .sub{color:var(--muted);font-size:13px}
    .card{display:grid;grid-template-columns:1fr;gap:16px}
    .cameraCard{background:var(--card);border-radius:12px;padding:14px;box-shadow:0 6px 18px rgba(16,24,40,0.06);position:relative;overflow:hidden;border:1px solid rgba(10,20,40,0.04)}
    canvas{width:100%;height:auto;background:#000;border-radius:8px;display:block}
    .controls{display:flex;gap:8px;align-items:center;margin-top:10px}
    .btn{background:var(--accent);color:#fff;padding:8px 12px;border-radius:999px;border:0;cursor:pointer;font-weight:600}
    .btn.ghost{background:transparent;border:1px solid rgba(10,20,40,0.06);color:var(--muted)}
    .panel{background:var(--card);border-radius:12px;padding:12px;color:var(--muted);height:100%;border:1px solid rgba(10,20,40,0.04)}
    pre{max-height:68vh;overflow:auto;background:transparent;color:var(--muted);padding:8px;border-radius:6px;margin:8px 0;font-family:Menlo,monospace}
    .badge{position:absolute;right:16px;top:16px;background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#fff; padding:6px 10px;border-radius:999px;font-weight:700}
    .statusLine{display:flex;gap:10px;align-items:center}
    .statusDot{width:10px;height:10px;border-radius:50%;background:#10b981;box-shadow:0 0 6px rgba(16,185,129,0.18)}
    .loader{position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,0.6);backdrop-filter:blur(4px)}
    .topActions{display:flex;gap:8px;align-items:center}
    .closeBtn{background:transparent;border:0;color:var(--muted);cursor:pointer;font-weight:700}
    .note{font-size:13px;color:var(--muted);margin-top:8px}
    .notices{display:flex;gap:8px;flex-direction:column;margin-bottom:12px}
    .notice{background:#eef6ff;border-left:4px solid var(--accent);padding:10px 12px;border-radius:8px;color:#07203a;font-weight:600}
    .notice.small{background:#f7fff9;border-left-color:var(--accent-2);font-weight:500}
    video{position:absolute;left:-9999px;top:-9999px}
    @media(max-width:880px){
        .card{grid-template-columns:1fr}
        .panel{height:auto}
    }
</style>

<div class="app">
    <div class="topbar">
        <div>
            <div class="title">TryOnX — Pose Camera</div>
            <div class="sub">측정용 카메라 · 드래그로 랜드마크 보정 가능</div>
        </div>
        <div class="topActions">
            <div class="sub">memberId: <strong id="memberIdDisp">-</strong></div>
            <button class="closeBtn" id="closeBtn">닫기 ✕</button>
        </div>
    </div>

    

    <div class="card">
        <div class="cameraCard">
            <div class="badge" id="bodyBadge">—</div>
            <div class="statusLine" style="margin-bottom:8px">
                <div class="statusDot" id="statusDot"></div>
                <div id="status" style="font-weight:700">대기중</div>
            </div>
            <canvas id="canvas"></canvas>
            <div class="controls">
                <button id="restartBtn" class="btn">재시작</button>
                <button id="stopBtn" class="btn ghost">중지</button>
                <div style="flex:1" />
                <div class="note">자동으로 시작됩니다. 측정 후 10초 뒤 자동 종료</div>
            </div>
            <div id="loader" class="loader" style="display:none">
                <div style="text-align:center;color:#fff">
                    <div style="font-size:18px;font-weight:700;margin-bottom:8px">모델 로딩 중…</div>
                    <div style="opacity:0.9">잠시만 기다려주세요</div>
                </div>
            </div>
        </div>

        
    </div>
    
</div>

<script type="module">
    // 서버가 주입하는 값: null 일 수도 있음
    const memberId = /*[[${memberId}]]*/ null;

    import { PoseLandmarker, FilesetResolver, DrawingUtils }
        from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

    const POSE_CONNECTIONS_FALLBACK = [
        [0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[12,14],[14,16],[15,17],[16,18],[17,19],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[31,32]
    ];

    const statusEl = document.getElementById('status');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const loaderEl = document.getElementById('loader');
    const badgeEl = document.getElementById('bodyBadge');
    const memberIdDisp = document.getElementById('memberIdDisp');
    const closeBtn = document.getElementById('closeBtn');
    const stopBtn = document.getElementById('stopBtn');
    const restartBtn = document.getElementById('restartBtn');

    const video = document.createElement('video');
    video.setAttribute('playsinline','');
    video.muted = true;
    document.body.appendChild(video);

    let landmarker, ws, running = false, lastSend = 0;
    const SEND_FPS = 5;
    let processing = false;

    let currentLm = [];
    let selectedIndex = null;
    let isDragging = false;

    const MEASURE_MS = 10_000;
    let startAt = 0;

    function stopCamera() {
        try {
            const stream = video.srcObject;
            if (stream) stream.getTracks().forEach(t => t.stop());
        } catch (e) { console.warn(e); }
    }

    function log(msg) {
        // Keep logs in console only (UI log removed)
        console.log(`[${new Date().toISOString()}] ${msg}`);
    }

    async function initModel() {
        statusEl.textContent = 'loading model...';
        loaderEl.style.display = 'flex';
        const resolver = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
        );
        landmarker = await PoseLandmarker.createFromOptions(resolver, {
            baseOptions: {
                modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/latest/pose_landmarker_lite.task"
            },
            runningMode: "VIDEO",
            numPoses: 1
        });
        statusEl.textContent = 'model loaded';
        loaderEl.style.display = 'none';
    }

    function openWS() {
        try{
            ws = new WebSocket(`ws://${location.host}/ws/pose`);
            ws.onopen = () => log('WS connected');
        }catch(e){console.warn('WS failed',e)}
    }

    async function startCamera() {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 640, height: 480, facingMode: 'user' },
            audio: false
        });
        video.srcObject = stream;
        await video.play();
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        running = true;
        if(memberIdDisp) memberIdDisp.textContent = String(memberId ?? '-');
        requestAnimationFrame(loop);
    }

    function classifyBodyType(lm) {
        if (!lm || lm.length < 33) return 'UNKNOWN';
        const dist = (a, b) => Math.abs(lm[a].x - lm[b].x);
        const shoulder = dist(11, 12);
        const hip = dist(23, 24);
        const waistY = (lm[23].y + lm[24].y) / 2 - 0.05;
        const leftWaist = lm.reduce((prev, cur) =>
            cur.x < 0.5 && Math.abs(cur.y - waistY) < Math.abs(prev.y - waistY) ? cur : prev
        );
        const rightWaist = lm.reduce((prev, cur) =>
            cur.x > 0.5 && Math.abs(cur.y - waistY) < Math.abs(prev.y - waistY) ? cur : prev
        );
        const waist = Math.abs(leftWaist.x - rightWaist.x);

        const avg = (shoulder + waist + hip) / 3;

        const isClose = (a, b) => Math.abs(a - b) / avg < 0.05;

        if (isClose(shoulder, waist) && isClose(waist, hip)) return 'STRAIGHT';
        if (shoulder > waist && shoulder > hip) return 'NATURAL';
        if (hip > waist && hip > shoulder) return 'WAVE';
        return 'STRAIGHT';
    }

    function updateLandmarks(newLm) {
        if (currentLm.length === 0) {
            currentLm = newLm.map(p => ({ ...p }));
        } else {
            newLm.forEach((p, i) => {
                if (!(isDragging && selectedIndex === i)) {
                    currentLm[i] = { ...p };
                }
            });
        }
    }

    // Map normalized landmark coordinates to canvas pixels (no mirror)
    function toCanvasCoords(lmPoint) {
        return { x: lmPoint.x * canvas.width, y: lmPoint.y * canvas.height };
    }

    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const ix = mx * scaleX;
        const iy = my * scaleY;
        selectedIndex = currentLm.findIndex(p => {
            const { x, y } = toCanvasCoords(p);
            return Math.hypot(ix - x, iy - y) < 10;
        });
        if (selectedIndex !== -1) isDragging = true;
    });
    canvas.addEventListener('mousemove', (e) => {
            if (isDragging && selectedIndex !== null && selectedIndex !== -1) {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            // convert displayed X back to normalized landmark X (no mirror)
            currentLm[selectedIndex].x = mx / rect.width;
            currentLm[selectedIndex].y = my / rect.height;
        }
    });
    canvas.addEventListener('mouseup', () => { isDragging = false; selectedIndex = null; });
    canvas.addEventListener('mouseleave', () => { isDragging = false; selectedIndex = null; });

    async function loop() {
        if (!running) return;

        const now = performance.now();
        if (now - startAt >= MEASURE_MS) {
            running = false;
            statusEl.textContent = '완료 (10초)';
            log('measurement finished (10s)');
            try { if (ws && ws.readyState === WebSocket.OPEN) ws.close(); } catch(e) { console.warn(e); }
            stopCamera();
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // draw video normally (no mirror) and then draw landmarks so they align
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        if (!processing) {
            processing = true;
            const res = await landmarker.detectForVideo(video, now);
            if (res?.landmarks?.[0]) updateLandmarks(res.landmarks[0]);

            if (currentLm.length > 0) {
                // draw landmarks and connectors in pixel coords so they match flipped video
                try{
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(255,255,255,0.95)';
                    ctx.fillStyle = 'rgba(255,255,255,0.95)';
                    const connections = (typeof PoseLandmarker !== 'undefined' && PoseLandmarker.POSE_CONNECTIONS) ? PoseLandmarker.POSE_CONNECTIONS : POSE_CONNECTIONS_FALLBACK;
                    // prefer DrawingUtils for consistent original appearance
                    if(typeof DrawingUtils !== 'undefined'){
                        try{
                            const d = new DrawingUtils(ctx);
                            d.drawConnectors(currentLm, connections);
                            d.drawLandmarks(currentLm);
                        }catch(e){
                            console.warn('DrawingUtils failed, falling back', e);
                            for(const conn of connections){ const a = currentLm[conn[0]]; const b = currentLm[conn[1]]; if(!a||!b) continue; if((a.visibility!=null && a.visibility < 0.15) || (b.visibility!=null && b.visibility < 0.15)) continue; const pa = toCanvasCoords(a); const pb = toCanvasCoords(b); ctx.beginPath(); ctx.moveTo(pa.x, pa.y); ctx.lineTo(pb.x, pb.y); ctx.strokeStyle = 'rgba(15,98,255,0.95)'; ctx.lineWidth = 6; ctx.lineCap = 'round'; ctx.stroke(); }
                            for(const p of currentLm){ const pt = toCanvasCoords(p); ctx.beginPath(); ctx.arc(pt.x, pt.y, 4, 0, Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=2; ctx.stroke(); }
                        }
                    } else {
                        for(const conn of connections){ const a = currentLm[conn[0]]; const b = currentLm[conn[1]]; if(!a||!b) continue; if((a.visibility!=null && a.visibility < 0.15) || (b.visibility!=null && b.visibility < 0.15)) continue; const pa = toCanvasCoords(a); const pb = toCanvasCoords(b); ctx.beginPath(); ctx.moveTo(pa.x, pa.y); ctx.lineTo(pb.x, pb.y); ctx.strokeStyle = 'rgba(15,98,255,0.95)'; ctx.lineWidth = 6; ctx.lineCap = 'round'; ctx.stroke(); }
                        for(const p of currentLm){ const pt = toCanvasCoords(p); ctx.beginPath(); ctx.arc(pt.x, pt.y, 4, 0, Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=2; ctx.stroke(); }
                    // overlay small dots to ensure consistent small landmark appearance
                    for(const p of currentLm){ try{ const pt = toCanvasCoords(p); ctx.beginPath(); ctx.arc(pt.x, pt.y, 4, 0, Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=1; ctx.stroke(); }catch(e){} }
                    }
                }catch(e){ console.warn('draw landmarks failed', e); }
            }

            const msPerSend = 1000 / SEND_FPS;
            if (ws && ws.readyState === WebSocket.OPEN && (now - lastSend) >= msPerSend) {
                lastSend = now;
                const bodyType = classifyBodyType(currentLm);
                const flat = currentLm.map(p => ({
                    x: +p.x.toFixed(6),
                    y: +p.y.toFixed(6),
                    z: +(p.z ?? 0).toFixed(6),
                    visibility: p.visibility != null ? +p.visibility.toFixed(3) : null
                }));

                // memberId 포함 전송
                try{ ws.send(JSON.stringify({
                    frameTs: Date.now(),
                    memberId: memberId,  // 주입된 값
                    bodyType,
                    landmarks: flat
                }));
                log(`sent ${bodyType} (memberId=${memberId})`);
                }catch(e){}
            }

            // update badge
            try{
                const bodyType = classifyBodyType(currentLm);
                if(badgeEl) badgeEl.textContent = bodyType;
            }catch(e){}

            processing = false;
        }
        requestAnimationFrame(loop);
    }

    closeBtn.addEventListener('click', () => {
        try{
            if(window.ReactNativeWebView && window.ReactNativeWebView.postMessage) {
                window.ReactNativeWebView.postMessage(JSON.stringify({type:'close'}));
            } else {
                window.close();
            }
        }catch(e){window.close();}
    });

    stopBtn.addEventListener('click', ()=>{
        running = false; stopCamera(); statusEl.textContent = '대기중';
    });

    // send a restart request to the server (if WS available) and restart local analysis
    function sendRestartRequest(){
        try{
            const payload = { type: 'restart', memberId };
            if(ws && ws.readyState === WebSocket.OPEN){ ws.send(JSON.stringify(payload)); log('sent restart request'); }
            else if(ws){ ws.addEventListener('open', ()=>{ ws.send(JSON.stringify(payload)); log('sent restart request on open'); }, { once: true }); }
        }catch(e){ console.warn('restart send failed', e); }
    }

    restartBtn.addEventListener('click', async ()=>{
        try{
            // reset local state
            currentLm = [];
            if(badgeEl) badgeEl.textContent = '—';
            startAt = performance.now();
            statusEl.textContent = '체형분석중';
            if(!landmarker) await initModel();
            openWS();
            sendRestartRequest();
            await startCamera();
        }catch(e){console.warn(e)}
    });

    // auto-start sequence
    window.onload = async () => {
        try{
            await initModel();
            openWS();
            await startCamera();
            startAt = performance.now();
            statusEl.textContent = 'running';
        }catch(e){
            console.error(e);
            statusEl.textContent = 'error';
            loaderEl.style.display = 'none';
            log('start failed: '+(e?.message||e));
        }
    };
</script>
