<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TryOnX — Camera</title>
<style>
    :root {
        --bg: #f8fafc;
        --card: #ffffff;
        --muted: #6b7280;
        --accent: #0f62ff;
        --success: #10b981
    }

    * {
        box-sizing: border-box
    }

    html,
    body {
        height: 100%;
        margin: 0;
        font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Arial
    }

    body {
        background: var(--bg);
        color: #07203a;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px
    }

    .wrap {
        width: 100%;
        max-width: 980px
    }

    .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 14px
    }

    .title {
        font-size: 20px;
        font-weight: 700;
        color: #07203a
    }

    .subtitle {
        font-size: 13px;
        color: var(--muted)
    }

    .card {
        background: var(--card);
        border-radius: 12px;
        padding: 14px;
        box-shadow: 0 8px 32px rgba(16, 24, 40, 0.06);
        border: 1px solid rgba(10, 20, 40, 0.04)
    }

    .cameraArea {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center
    }

    canvas {
        width: 100%;
        height: auto;
        background: #000;
        border-radius: 10px;
        display: block
    }

    .status {
        position: absolute;
        left: 14px;
        top: 14px;
        background: #eef6ff;
        color: #07203a;
        padding: 7px 12px;
        border-radius: 999px;
        font-weight: 700;
        border-left: 4px solid var(--accent)
    }

    .badge {
        position: absolute;
        right: 14px;
        top: 14px;
        background: linear-gradient(90deg, var(--accent), #00c3a6);
        color: #fff;
        padding: 8px 14px;
        border-radius: 999px;
        font-weight: 800;
        font-size: 16px;
        box-shadow: 0 6px 18px rgba(16, 24, 40, 0.06)
    }

    .noticeTop {
        width: 100%;
        max-width: 980px;
        margin: 0 auto 12px;
        display: flex;
        gap: 12px;
        flex-direction: column
    }

    .noticeTop .item {
        background: #fff3e8;
        border-left: 4px solid #ff8a00;
        padding: 12px 14px;
        border-radius: 10px;
        color: #7a2b00;
        font-weight: 700
    }

    .noticeTop .item.privacy {
        background: #eefef7;
        border-left-color: #00bfa6;
        color: #064e3b;
        font-weight: 600
    }

    .resultOverlay {
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(2, 6, 23, 0.45);
        z-index: 999
    }

    .resultCard {
        background: #fff;
        border-radius: 14px;
        padding: 28px 32px;
        min-width: 320px;
        max-width: 420px;
        text-align: center;
        box-shadow: 0 12px 40px rgba(2, 6, 23, 0.25)
    }

    .resultTitle {
        font-size: 14px;
        color: #6b7280;
        margin-bottom: 8px
    }

    .resultType {
        font-size: 36px;
        font-weight: 900;
        color: #07203a;
        margin-bottom: 6px
    }

    .resultSub {
        font-size: 14px;
        color: #6b7280;
        margin-bottom: 14px
    }

    .resultClose {
        background: var(--accent);
        color: #fff;
        padding: 10px 18px;
        border-radius: 999px;
        border: 0;
        cursor: pointer;
        font-weight: 700
    }

    .controls {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-top: 12px
    }

    .btn {
        background: var(--accent);
        color: #fff;
        padding: 9px 14px;
        border-radius: 999px;
        border: 0;
        cursor: pointer;
        font-weight: 700
    }

    .btn.ghost {
        background: transparent;
        border: 1px solid rgba(10, 20, 40, 0.06);
        color: var(--muted)
    }

    .note {
        font-size: 13px;
        color: var(--muted);
        margin-top: 10px
    }

    .error {
        display: none;
        background: #fff6f4;
        border: 1px solid #ffb4a2;
        color: #7a2719;
        padding: 12px;
        border-radius: 8px;
        margin-top: 12px
    }

    video {
        display: none
    }

    @media(max-width:760px) {
        .header {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px
        }
    }
</style>

<div class="wrap">
    <!-- <div class="header">
        <div>
            <div class="title">TryOnX</div>
            <div class="subtitle">체형 측정용 카메라 — 간단하고 빠르게</div>
        </div>
        <div class="subtitle">memberId: <strong id="memberIdDisp">-</strong></div>
    </div> -->

    <!-- Top Notices (prominent) -->
    <div class="noticeTop" aria-hidden="false">
        <div class="item" style="font-size:12px;">체형 인식할 수 있게 <strong>타이트한 옷</strong>을 입고 진행해주세요.</div>
        <div class="item privacy" style="font-size:12px;">사진은 저장되지 않으며, 개인정보로 활용되지 않습니다.</div>
    </div>

    <div class="card">
        <div class="cameraArea">
            <div class="status" id="status">대기중</div>
            <div class="badge" id="bodyBadge">—</div>
            <canvas id="canvas"></canvas>
            <!-- <div class="controls">
                <button id="retryBtn" class="btn">다시 분석하기</button>
                <div style="flex:1"></div>
            </div> -->
            <div id="cameraError" class="error" role="alert">카메라 접근에 실패했습니다. 권한·설정 확인 후 새로고침 해주세요.</div>
        </div>
    </div>

    <!-- Final result overlay -->
    <div id="resultOverlay" class="resultOverlay" role="dialog" aria-modal="true">
        <div class="resultCard">
            <div class="resultTitle">최종 체형 결과</div>
            <div id="resultType" class="resultType">—</div>
            <!-- <div class="resultSub">AI피팅</div> -->
            <button id="resultClose" class="resultClose">확인</button>
        </div>
    </div>
</div>

<!--<script type="module" th:inline="javascript">-->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>

<script type="module">
    const memberId = /*[[${memberId}]]*/ null;
    const memberIdDisp = document.getElementById('memberIdDisp');
    if (memberIdDisp) memberIdDisp.textContent = String(memberId ?? '-');

    import { PoseLandmarker, FilesetResolver, DrawingUtils }
        from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";
    import { ImageSegmenter }
        from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

// fallback POSE connections (MediaPipe default) in case PoseLandmarker.POSE_CONNECTIONS is unavailable
    const POSE_CONNECTIONS_FALLBACK = [
        [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8], [9, 10], [11, 12], [11, 13], [13, 15], [12, 14], [14, 16], [15, 17], [16, 18], [17, 19], [18, 20], [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [31, 32]
    ];

    const statusEl = document.getElementById('status');
    const badgeEl = document.getElementById('bodyBadge');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const cameraErrorEl = document.getElementById('cameraError');

    const retryBtn = document.getElementById('retryBtn');
    const resultOverlay = document.getElementById('resultOverlay');
    const resultTypeEl = document.getElementById('resultType');
    const resultCloseBtn = document.getElementById('resultClose');

    const video = document.createElement('video');
    video.setAttribute('playsinline', '');
    video.muted = true;
    document.body.appendChild(video);

    let landmarker, ws, running = false, processing = false, lastSend = 0;
    const SEND_FPS = 5;
    let currentLm = [], smoothLm = [], selectedIndex = null, isDragging = false;
    const bodyCounts = { STRAIGHT: 0, NATURAL: 0, WAVE: 0, UNKNOWN: 0 };
    const MEASURE_MS = 10_000; let startAt = 0;
    const SMOOTH = 0.32;

    function smoothLandmarks(raw) {
        if (!smoothLm.length) {
            smoothLm = raw.map(p => ({ ...p }));
            return smoothLm;
        }
        raw.forEach((p, i) => {
            smoothLm[i].x = smoothLm[i].x * (1 - SMOOTH) + p.x * SMOOTH;
            smoothLm[i].y = smoothLm[i].y * (1 - SMOOTH) + p.y * SMOOTH;
            smoothLm[i].z = smoothLm[i].z * (1 - SMOOTH) + (p.z ?? 0) * SMOOTH;
        });
        return smoothLm;
    }
    function isFrontPose(lm) {
        const sDiff = Math.abs(lm[11].y - lm[12].y);
        const hDiff = Math.abs(lm[23].y - lm[24].y);
        const noseCenter = Math.abs(lm[0].x - 0.5);

        return (sDiff < 0.05 && hDiff < 0.05 && noseCenter < 0.18);
    }
    function widthAtY(lm, y) {
        const left = lm.filter(p => p.x < 0.5)
            .reduce((a, b) => Math.abs(b.y - y) < Math.abs(a.y - y) ? b : a);

        const right = lm.filter(p => p.x > 0.5)
            .reduce((a, b) => Math.abs(b.y - y) < Math.abs(a.y - y) ? b : a);

        return Math.abs(left.x - right.x);
    }

    function midpoint(a, b) {
        return {
            x: (a.x + b.x) / 2,
            y: (a.y + b.y) / 2,
            z: (a.z + b.z) / 2,
            visibility: Math.min(a.visibility ?? 1, b.visibility ?? 1)
        };
    }

    function log(msg) { console.log(msg); }

    let segmenter = null;

    async function initSegmentationModel() {
        const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
        );

        segmenter = await ImageSegmenter.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath:
                    "https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_segmenter_landscape/float16/1/selfie_segmenter_landscape.task"
            },
            runningMode: "VIDEO",
            outputCategoryMask: true
        });
        await segmenter.setOptions({ runningMode: "VIDEO" });
    }

    async function initModel() {
        statusEl.textContent = 'loading model...';
        const resolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
        landmarker = await PoseLandmarker.createFromOptions(resolver, {
            baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/latest/pose_landmarker_lite.task" },
            runningMode: 'VIDEO', numPoses: 1
        });
        statusEl.textContent = 'model loaded';
    }

    function openWS() {
        try { const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws'; ws = new WebSocket(`${wsScheme}://${location.host}/ws/pose`); ws.onopen = () => log('WS connected'); } catch (e) { console.warn(e) }
    }

    async function startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
            video.srcObject = stream; await video.play();

            // use actual video dimensions for canvas internal size for precise mapping
            const vw = video.videoWidth || Math.round(window.innerWidth * (window.devicePixelRatio || 1));
            const vh = video.videoHeight || Math.round(window.innerHeight * (window.devicePixelRatio || 1));

            // compute display width to fit mobile viewport (respect body padding and parent width)
            const parentWidth = canvas.parentElement ? canvas.parentElement.clientWidth : window.innerWidth;
            const viewportPadding = 40; // body has ~20px padding each side
            const maxViewportWidth = Math.max(0, window.innerWidth - viewportPadding);
            const displayWidth = Math.min(parentWidth, maxViewportWidth);
            const displayHeight = Math.round(displayWidth * (vh / vw));

            // set canvas internal pixel size to video resolution and limit CSS display size to viewport
            canvas.width = vw;
            canvas.height = vh;
            canvas.style.maxWidth = '100%';
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';

            // reset runtime flags so a restarted session actually processes frames
            processing = false; // allow the loop to run detectForVideo again
            lastSend = 0;
            selectedIndex = null;
            currentLm = [];

            running = true; startAt = performance.now(); requestAnimationFrame(loop);
            cameraErrorEl && (cameraErrorEl.style.display = 'none');
            statusEl.textContent = '체형분석중';
        } catch (e) {
            console.error(e);
            cameraErrorEl && (cameraErrorEl.style.display = 'block');
            statusEl.textContent = 'camera error';
            throw e;
        }
    }

    function stopCamera() {
        try {
            const s = video.srcObject;
            if (s) s.getTracks().forEach(t => t.stop());
        } catch (e) { }
        running = false;
        if (!keepStatus) {
            statusEl.textContent = '대기중';
        }
    }

    // function classifyBodyType(lm) {
    //     if (!lm || lm.length < 33) return 'UNKNOWN';
    //     const dist = (a, b) => Math.abs(lm[a].x - lm[b].x);
    //     const shoulder = dist(11, 12); const hip = dist(23, 24);
    //     const waistY = (lm[23].y + lm[24].y) / 2 - 0.05;
    //     const leftWaist = lm.reduce((prev, cur) => cur.x < 0.5 && Math.abs(cur.y - waistY) < Math.abs(prev.y - waistY) ? cur : prev);
    //     const rightWaist = lm.reduce((prev, cur) => cur.x > 0.5 && Math.abs(cur.y - waistY) < Math.abs(prev.y - waistY) ? cur : prev);
    //     const waist = Math.abs(leftWaist.x - rightWaist.x); const avg = (shoulder + waist + hip) / 3; const isClose = (a, b) => Math.abs(a - b) / avg < 0.05;
    //     if (isClose(shoulder, waist) && isClose(waist, hip)) return 'STRAIGHT'; if (shoulder > waist && shoulder > hip) return 'NATURAL'; if (hip > waist && hip > shoulder) return 'WAVE'; return 'STRAIGHT';
    // }

    // function classifyBodyType(lm) {
    //     if (!lm || lm.length < 33) return "UNKNOWN";
    //     if (!isFrontPose(lm)) return "UNKNOWN";
    //
    //     const shoulder = Math.abs(lm[11].x - lm[12].x);
    //     const hip = Math.abs(lm[23].x - lm[24].x);
    //
    //     const waistY = (lm[11].y + lm[12].y + lm[23].y + lm[24].y) / 4;
    //     const waist = widthAtY(lm, waistY);
    //
    //     const avg = (shoulder + waist + hip) / 3;
    //     const close = (a, b) => Math.abs(a - b) / avg < 0.06;
    //
    //     if (close(shoulder, waist) && close(waist, hip)) return "STRAIGHT";
    //     if (shoulder > waist && shoulder > hip) return "NATURAL";
    //     if (hip > waist && hip > shoulder) return "WAVE";
    //
    //     return "STRAIGHT";
    // }

    function findHipY(lm) {
        const topY = (lm[11].y + lm[12].y) / 2;  // 어깨 중심
        const botY = Math.min(lm[25].y, lm[26].y); // 허벅지 상단

        let bestY = topY;
        let bestW = 0;

        for (let i = topY; i <= botY; i += 0.005) {
            const w = widthAtY(lm, i);
            if (w > bestW) {
                bestW = w;
                bestY = i;
            }
        }

        return bestY;
    }

    function classifyBodyType(lm) {
        if (!lm || lm.length < 33) return "UNKNOWN";
        if (!isFrontPose(lm)) return "UNKNOWN";

        // 기본 너비 계산
        const shoulder = Math.abs(lm[11].x - lm[12].x);
        // const hip = Math.abs(lm[23].x - lm[24].x);

        // 허리 지점
        const waistY = (lm[11].y + lm[12].y + lm[23].y + lm[24].y) / 4;
        const waist = widthAtY(lm, waistY);

        // 엉덩이 지점(최대 폭)
        const hipY_raw = findHipY(lm);

        // 바지 허리선 = 허리~엉덩이 중간 45%
        const pelvisY = waistY + (hipY_raw - waistY) * 0.85;

        // 최종 골반 폭
        const hip = widthAtY(lm, pelvisY);

        // 허리 Y 지점 = 어깨/골반의 중간
        // const waistY = (lm[11].y + lm[12].y + lm[23].y + lm[24].y) / 4;
        // const waist = widthAtY(lm, waistY);

        // 가슴 Y 지점 (어깨보다 약간 아래)
        const chestY = (lm[11].y + lm[12].y) / 2 + 0.05;
        const chest = widthAtY(lm, chestY);

        // 곡률(허리가 얼마나 들어갔는지)
        const curvature = chest - waist;

        // 평균값
        const avg = (shoulder + waist + hip) / 3;
        const close = (a, b, tol = 0.06) => Math.abs(a - b) / avg < tol;

        // --- STRAIGHT ---
        // 전체 폭이 비슷 + 허리 굴곡 적음
        if (close(shoulder, waist) && close(waist, hip) && curvature < avg * 0.05) {
            return "STRAIGHT";
        }

        // --- WAVE ---
        // 골반이 가장 넓고 허리가 들어간 곡선형
        if (hip > shoulder && hip > chest && curvature > avg * 0.04) {
            return "WAVE";
        }

        // --- NATURAL ---
        // 어깨가 가장 넓고 허리 굴곡은 적당함
        if (shoulder > hip && curvature <= avg * 0.08) {
            return "NATURAL";
        }

        // 기본 fallback
        return "STRAIGHT";
    }

    function updateLandmarks(newLm) {
        if (currentLm.length === 0)
            currentLm = newLm.map(p => ({ x: 1 - p.x, y: p.y, z: p.z, visibility: p.visibility }));
        else
            newLm.forEach((p, i) => {
                if (!(isDragging && selectedIndex === i))
                    currentLm[i] = { x: 1 - p.x, y: p.y, z: p.z, visibility: p.visibility };
            });
    }

    // canvas coordinate mapping (no mirror) -> map normalized landmarks to canvas pixels
    function toCanvasCoords(lmPoint) { return { x: lmPoint.x * canvas.width, y: lmPoint.y * canvas.height }; }

    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
        const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
        const ix = mx * scaleX; const iy = my * scaleY;
        selectedIndex = smoothLm.findIndex(p => { const { x, y } = toCanvasCoords(p); return Math.hypot(ix - x, iy - y) < 10; });
        if (selectedIndex !== -1) isDragging = true;
    });
    canvas.addEventListener('mousemove', (e) => {
        if (isDragging && selectedIndex !== null && selectedIndex !== -1) {
            const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
            smoothLm[selectedIndex].x = 1 - (mx / rect.width);
            smoothLm[selectedIndex].y = my / rect.height;
        }
    });
    canvas.addEventListener('mouseup', () => { isDragging = false; selectedIndex = null; });
    canvas.addEventListener('mouseleave', () => { isDragging = false; selectedIndex = null; });

    async function loop() {
        if (!running) return; const now = performance.now();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // draw video normally (no mirror) and then draw landmarks so they align
        // ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.scale(-1, 1);
        ctx.translate(-canvas.width, 0);
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        ctx.restore();
        if (!processing) {
            processing = true; const res = await landmarker.detectForVideo(video, now); if (res?.landmarks?.[0]) updateLandmarks(res.landmarks[0]);
            // ========== segmentation으로 골반 외곽 확장 =============
            if (segmenter && currentLm.length > 0) {

                const { categoryMask } = await segmenter.segmentForVideo(video, now);

                if (categoryMask) {

                    // Uint8Array로 변환
                    const mask = new Uint8Array(categoryMask.buffer);

                    const width = categoryMask.width;
                    const height = categoryMask.height;

                    // pelvisY
                    const waistY = (currentLm[11].y + currentLm[12].y + currentLm[23].y + currentLm[24].y) / 4;
                    const hipY_raw = findHipY(currentLm);
                    const pelvisY = waistY + (hipY_raw - waistY) * 0.45;

                    // 실루엣 외곽
                    const edges = findSilhouetteEdges(mask, width, height, pelvisY);

                    if (edges.left !== null && edges.right !== null) {

                        const scale = 1.15;  // 골반 폭 확장 (10~20% 추천)

                        const mid = (edges.left + edges.right) / 2;  // 중심점

                        // scale 적용해서 양 옆으로 확장
                        let leftX  = mid - (mid - edges.left) * scale;
                        let rightX = mid + (edges.right - mid) * scale;

                        // 범위를 mask 내부로 클램핑(안 하면 좌표 튀는 경우 있음)
                        leftX = Math.max(0, Math.min(width - 1, leftX));
                        rightX = Math.max(0, Math.min(width - 1, rightX));

                        // 0~1 정규화하여 landmark 반영
                        currentLm[24].x = leftX / width;
                        currentLm[23].x = rightX / width;

                        // Y는 pelvisY에 맞추기
                        currentLm[23].y = pelvisY;
                        currentLm[24].y = pelvisY;
                    }

                }
            }
// =============================================================

            if (currentLm.length > 0) {
                // draw landmarks and connectors in pixel coordinates so they match the flipped video
                try {
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(255,255,255,0.95)';
                    ctx.fillStyle = 'rgba(255,255,255,0.95)';
                    const connections = (typeof PoseLandmarker !== 'undefined' && PoseLandmarker.POSE_CONNECTIONS) ? PoseLandmarker.POSE_CONNECTIONS : POSE_CONNECTIONS_FALLBACK;
                    // prefer DrawingUtils for consistent original appearance
                    if (typeof DrawingUtils !== 'undefined') {
                        try {
                            const d = new DrawingUtils(ctx);
                            d.drawConnectors(currentLm, connections);
                            d.drawLandmarks(currentLm);
                        } catch (e) {
                            // fallback to manual draw below
                            console.warn('DrawingUtils failed, falling back', e);
                            for (const conn of connections) {
                                const a = currentLm[conn[0]]; const b = currentLm[conn[1]]; if (!a || !b) continue;
                                if ((a.visibility != null && a.visibility < 0.15) || (b.visibility != null && b.visibility < 0.15)) continue;
                                const pa = toCanvasCoords(a); const pb = toCanvasCoords(b);
                                ctx.beginPath(); ctx.moveTo(pa.x, pa.y); ctx.lineTo(pb.x, pb.y); ctx.strokeStyle = 'rgba(15,98,255,0.95)'; ctx.lineWidth = 6; ctx.lineCap = 'round'; ctx.stroke();
                            }
                            for (const p of currentLm) { const pt = toCanvasCoords(p); ctx.beginPath(); ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,0.35)'; ctx.lineWidth = 2; ctx.stroke(); }
                        }
                    } else {
                        // manual draw if DrawingUtils not available
                        for (const conn of connections) {
                            const a = currentLm[conn[0]]; const b = currentLm[conn[1]]; if (!a || !b) continue;
                            if ((a.visibility != null && a.visibility < 0.15) || (b.visibility != null && b.visibility < 0.15)) continue;
                            const pa = toCanvasCoords(a); const pb = toCanvasCoords(b);
                            ctx.beginPath(); ctx.moveTo(pa.x, pa.y); ctx.lineTo(pb.x, pb.y); ctx.strokeStyle = 'rgba(15,98,255,0.95)'; ctx.lineWidth = 6; ctx.lineCap = 'round'; ctx.stroke();
                        }
                        for (const p of currentLm) { const pt = toCanvasCoords(p); ctx.beginPath(); ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,0.35)'; ctx.lineWidth = 2; ctx.stroke(); }
                        // overlay small dots to ensure consistent small landmark appearance
                        for (const p of currentLm) { try { const pt = toCanvasCoords(p); ctx.beginPath(); ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,0.35)'; ctx.lineWidth = 1; ctx.stroke(); } catch (e) { } }
                    }
                } catch (e) { console.warn('draw landmarks failed', e); }
                // ===== Custom virtual landmarks (12-24, 11-23) =====
                if (currentLm.length >= 33) {
                    const leftMid  = midpoint(currentLm[12], currentLm[24]); // 왼쪽 몸통 중앙
                    const rightMid = midpoint(currentLm[11], currentLm[23]); // 오른쪽 몸통 중앙

                    // 캔버스 좌표로 변환
                    const leftPt = toCanvasCoords(leftMid);
                    const rightPt = toCanvasCoords(rightMid);

                    // 두 점 그리기
                    ctx.beginPath();
                    ctx.arc(leftPt.x, leftPt.y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255,255,255,0.95)';
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(rightPt.x, rightPt.y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255,255,255,0.95)';
                    ctx.fill();

                    // 두 중간점을 연결하는 선 그리기 (선택)
                    ctx.beginPath();
                    ctx.moveTo(leftPt.x, leftPt.y);
                    ctx.lineTo(rightPt.x, rightPt.y);
                    ctx.strokeStyle = 'rgba(255,255,255,0.95)';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }

            }

            const msPerSend = 1000 / SEND_FPS;
            if (ws && ws.readyState === WebSocket.OPEN && (now - lastSend) >= msPerSend) {
                lastSend = now;
                // const bodyType = classifyBodyType(currentLm);
                const lmForType = smoothLm.length ? smoothLm : currentLm;
                const bodyType = classifyBodyType(lmForType);

                // local aggregation for final decision
                if (bodyType && bodyCounts.hasOwnProperty(bodyType)) bodyCounts[bodyType]++;
                const flat = currentLm.map(p => ({ x: +p.x.toFixed(6), y: +p.y.toFixed(6), z: +(p.z ?? 0).toFixed(6), visibility: p.visibility != null ? +p.visibility.toFixed(3) : null }));
                try { ws.send(JSON.stringify({ frameTs: Date.now(), memberId: memberId, bodyType, landmarks: flat })); log(`sent ${bodyType} (memberId=${memberId})`); } catch (e) { }
                if (badgeEl) badgeEl.textContent = typeof bodyType === 'string' ? bodyType : '—';
            }
            if (now - startAt >= MEASURE_MS) {
                running = false;
                // determine final body type by majority
                let finalType = 'UNKNOWN';
                // try {
                //     const entries = Object.entries(bodyCounts).sort((a, b) => b[1] - a[1]);
                //     if (entries.length > 0 && entries[0][1] > 0) finalType = entries[0][0];
                // } catch (e) { console.warn(e); }
                try {
                    const weights = { STRAIGHT: 1, NATURAL: 1, WAVE: 1, UNKNOWN: 0.2 };

                    finalType =
                        Object.entries(bodyCounts)
                            .sort((a, b) => (b[1] * weights[b[0]]) - (a[1] * weights[a[0]]))[0][0];

                } catch (e) { console.warn(e); }

                statusEl.textContent = '측정 완료';
                if (badgeEl) badgeEl.textContent = finalType;
                log('measurement finished (10s). final: ' + finalType + ' counts=' + JSON.stringify(bodyCounts));
                try { if (ws && ws.readyState === WebSocket.OPEN) ws.close(); } catch (e) { }
                // show final result overlay (and send to RN if available)
                if (resultTypeEl) resultTypeEl.textContent = finalType;
                if (resultOverlay) resultOverlay.style.display = 'flex';
                try { if (window.ReactNativeWebView && window.ReactNativeWebView.postMessage) window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'bodyResult', bodyType: finalType })); } catch (e) { }
                stopCamera(true);
                return;
            }
            processing = false;
        }
        requestAnimationFrame(loop);
    }

    if (retryBtn) retryBtn.addEventListener('click', async () => {
        try {
            // reset counts and UI
            for (const k of Object.keys(bodyCounts)) bodyCounts[k] = 0;
            if (badgeEl) badgeEl.textContent = '—';
            statusEl.textContent = '대기중';
            if (!landmarker) await initModel();
            openWS();
            await startCamera();
        } catch (e) { console.warn(e); }
    });
    if (resultCloseBtn) resultCloseBtn.addEventListener('click', () => { if (resultOverlay) resultOverlay.style.display = 'none'; });

    function findSilhouetteEdges(mask, width, height, yNorm, flipped = true) {
        // yNorm(0~1)을 segmentation mask 해상도에 맞춤
        let y = Math.floor(yNorm * height);
        if (y < 0) y = 0;
        if (y >= height) y = height - 1;

        let left = null, right = null;

        const TH = 80;

        if (!flipped) {
            for (let x = 0; x < width; x++) {
                const v = mask[y * width + x];
                if (v >= TH) { left = x; break; }
            }
            for (let x = width - 1; x >= 0; x--) {
                const v = mask[y * width + x];
                if (v >= TH) { right = x; break; }
            }
        } else {
            for (let x = 0; x < width; x++) {
                const v = mask[y * width + (width - 1 - x)];
                if (v >= TH) { left = x; break; }
            }
            for (let x = width - 1; x >= 0; x--) {
                const v = mask[y * width + (width - 1 - x)];
                if (v >= TH) { right = x; break; }
            }
        }

        return { left, right };
    }

    // auto start on load where possible
    window.onload = async () => { try { await initModel(); await startCamera(); openWS(); await initSegmentationModel(); } catch (e) { console.warn('auto start failed', e); } };
</script>