<!doctype html>
<meta charset="utf-8" />
<title>Pose Test + Drag</title>
<style>
    body { margin:0; background:#111; color:#fff; font-family:system-ui,sans-serif }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:12px; padding:12px }
    canvas { width:100%; height:auto; background:#000; border-radius:8px; cursor:crosshair }
    pre { max-height: 60vh; overflow:auto; background:#1e1e1e; padding:8px; border-radius:8px }
    video { position:absolute; top:-9999px; left:-9999px; }
</style>

<div class="grid">
    <div>
        <span id="status">idle</span>
        <canvas id="canvas"></canvas>
    </div>
    <div>
        <h3>로그</h3>
        <pre id="log"></pre>
        <div>최근 결과 REST: <code>/api/v1/bodytype/latest</code></div>
    </div>
</div>

<script type="module" th:inline="javascript">
    // 서버가 주입하는 값
    const memberId = /*[[${memberId}]]*/ null; // ← 이 줄 유지
    // WS 스킴 자동
    const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws';
    // openWS에서 사용: new WebSocket(`${wsScheme}://${location.host}/ws/pose`);
    import { PoseLandmarker, FilesetResolver, DrawingUtils }
        from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

    const statusEl = document.getElementById('status');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const logEl = document.getElementById('log');

    const video = document.createElement('video');
    video.setAttribute('playsinline','');
    video.muted = true;
    document.body.appendChild(video);

    let landmarker, ws, running = false, lastSend = 0;
    const SEND_FPS = 5;
    let processing = false;

    let currentLm = [];
    let selectedIndex = null;
    let isDragging = false;

    const MEASURE_MS = 10_000;
    let startAt = 0;

    // 전역 에러/프로미스 에러도 화면에 찍기
    window.addEventListener('error', (e) => log('window error: ' + (e?.message || e)));
    window.addEventListener('unhandledrejection', (e) => log('unhandled: ' + (e?.reason || e)));

    function stopCamera() {
        try {
            const stream = video.srcObject;
            if (stream) stream.getTracks().forEach(t => t.stop());
        } catch (e) { console.warn(e); }
    }

    function log(msg) {
        logEl.textContent = `[${new Date().toISOString()}] ${msg}\n` + logEl.textContent;
        console.log(msg);
    }

    async function initModel() {
        try {
            statusEl.textContent = 'loading model...';
            log('initModel: start');
            const resolver = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
            );
            landmarker = await PoseLandmarker.createFromOptions(resolver, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/latest/pose_landmarker_lite.task"
                },
                runningMode: "VIDEO",
                numPoses: 1
            });
            statusEl.textContent = 'model loaded';
            log('initModel: done');
        } catch (e) {
            log('initModel error: ' + (e?.message || e));
            throw e;
        }
    }

    function openWS() {
        const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws';
        const url = `${wsScheme}://${location.host}/ws/pose`;
        log('WS connect: ' + url);
        ws = new WebSocket(url);
        ws.onopen = () => log('WS connected');
        ws.onerror = (e) => log('WS error');
        ws.onclose = (e) => log('WS closed: code=' + e.code);
        ws.onmessage = (e) => { /* 서버 {"ok":true} 응답 등 필요시 log */ };
    }

    async function startCamera() {
        try {
            log('startCamera: requesting getUserMedia');
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480, facingMode: 'user' },
                audio: false
            });
            log('startCamera: granted');
            video.srcObject = stream;
            await video.play();
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            running = true;
            requestAnimationFrame(loop);
        } catch (e) {
            log('camera error: ' + (e?.name || e));
            alert('카메라 접근 실패: 권한/HTTPS/기기 설정을 확인하세요.\n' + (e?.message || e));
            throw e;
        }
    }

    function classifyBodyType(lm) {
        if (!lm || lm.length < 33) return 'UNKNOWN';
        const dist = (a, b) => Math.abs(lm[a].x - lm[b].x);
        const shoulder = dist(11, 12);
        const hip = dist(23, 24);
        const waistY = (lm[23].y + lm[24].y) / 2 - 0.05;
        const leftWaist = lm.reduce((prev, cur) =>
            cur.x < 0.5 && Math.abs(cur.y - waistY) < Math.abs(prev.y - waistY) ? cur : prev
        );
        const rightWaist = lm.reduce((prev, cur) =>
            cur.x > 0.5 && Math.abs(cur.y - waistY) < Math.abs(prev.y - waistY) ? cur : prev
        );
        const waist = Math.abs(leftWaist.x - rightWaist.x);
        const avg = (shoulder + waist + hip) / 3;
        const isClose = (a, b) => Math.abs(a - b) / avg < 0.05;
        if (isClose(shoulder, waist) && isClose(waist, hip)) return 'STRAIGHT';
        if (shoulder > waist && shoulder > hip) return 'NATURAL';
        if (hip > waist && hip > shoulder) return 'WAVE';
        return 'STRAIGHT';
    }

    function updateLandmarks(newLm) {
        if (currentLm.length === 0) {
            currentLm = newLm.map(p => ({ ...p }));
        } else {
            newLm.forEach((p, i) => {
                if (!(isDragging && selectedIndex === i)) currentLm[i] = { ...p };
            });
        }
    }

    function toCanvasCoords(lmPoint) {
        return { x: lmPoint.x * canvas.width, y: lmPoint.y * canvas.height };
    }

    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        selectedIndex = currentLm.findIndex(p => {
            const { x, y } = toCanvasCoords(p);
            return Math.hypot(mx - x, my - y) < 10;
        });
        if (selectedIndex !== -1) isDragging = true;
    });
    canvas.addEventListener('mousemove', (e) => {
        if (isDragging && selectedIndex !== null && selectedIndex !== -1) {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            currentLm[selectedIndex].x = mx / canvas.width;
            currentLm[selectedIndex].y = my / canvas.height;
        }
    });
    canvas.addEventListener('mouseup', () => { isDragging = false; selectedIndex = null; });
    canvas.addEventListener('mouseleave', () => { isDragging = false; selectedIndex = null; });

    async function loop() {
        if (!running) return;

        const now = performance.now();
        if (now - startAt >= MEASURE_MS) {
            running = false;
            statusEl.textContent = 'done (10s)';
            log('measurement finished (10s)');
            try { if (ws && ws.readyState === WebSocket.OPEN) ws.close(); } catch(e) { console.warn(e); }
            stopCamera();
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        if (!processing) {
            processing = true;
            const res = await landmarker.detectForVideo(video, now);
            if (res?.landmarks?.[0]) updateLandmarks(res.landmarks[0]);

            if (currentLm.length > 0) {
                const d = new DrawingUtils(ctx);
                d.drawLandmarks(currentLm);
                d.drawConnectors(currentLm, PoseLandmarker.POSE_CONNECTIONS);
            }

            const msPerSend = 1000 / SEND_FPS;
            if (ws && ws.readyState === WebSocket.OPEN && (now - lastSend) >= msPerSend) {
                lastSend = now;
                const bodyType = classifyBodyType(currentLm);
                const flat = currentLm.map(p => ({
                    x: +p.x.toFixed(6),
                    y: +p.y.toFixed(6),
                    z: +(p.z ?? 0).toFixed(6),
                    visibility: p.visibility != null ? +p.visibility.toFixed(3) : null
                }));

                ws.send(JSON.stringify({
                    frameTs: Date.now(),
                    memberId: memberId,
                    bodyType,
                    landmarks: flat
                }));
                log(`sent ${bodyType} (memberId=${memberId})`);
            }
            processing = false;
        }
        requestAnimationFrame(loop);
    }

    // iOS/모바일에서 사용자 제스처 필요할 수 있으니 버튼 시작도 고려 가능
    window.onload = async () => {
        try {
            log('page onload');
            await initModel();
            openWS();
            await startCamera();
            startAt = performance.now();
            statusEl.textContent = 'running';
            log('all started');
        } catch (e) {
            // 이미 각 함수에서 alert/log 처리함
        }
    };
</script>
